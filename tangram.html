<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>互动七巧板 (图例版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            touch-action: none;
        }
        canvas {
            cursor: grab;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        canvas:active {
            cursor: grabbing;
        }
        .pattern-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        #winModal {
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl mx-auto">
        <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-lg text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-slate-800 mb-2">七巧板挑战</h1>
            <p class="text-slate-600 mb-2">选择一个图案，然后把所有板块拼进去吧！</p>
            <p class="text-slate-500 text-sm mb-4"><b>操作方法：</b>拖动板块进行移动，双击或快速点按两次来旋转板块。</p>
            
            <div id="patternSelector" class="flex justify-center space-x-2 mb-4"></div>

            <div class="aspect-square w-full max-w-xl mx-auto bg-white rounded-xl relative">
                 <canvas id="tangramCanvas"></canvas>
            </div>

            <div class="mt-6 flex justify-center space-x-4">
                <button id="resetButton" class="bg-indigo-600 text-white font-semibold py-3 px-8 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-transform transform hover:scale-105">
                    重置
                </button>
                <button id="answerButton" class="bg-gray-600 text-white font-semibold py-3 px-8 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition-transform transform hover:scale-105">
                    显示答案
                </button>
            </div>
        </div>
    </div>

    <div id="winModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 opacity-0 pointer-events-none">
        <div class="bg-white rounded-2xl shadow-xl p-8 text-center transform scale-95 transition-transform">
            <h2 class="text-3xl font-bold text-green-500 mb-4">太棒了！</h2>
            <p class="text-slate-700 mb-6">你成功拼出了 <span id="winPatternName" class="font-bold"></span> 图案！</p>
            <button id="nextPatternButton" class="bg-green-500 text-white font-semibold py-2 px-6 rounded-lg hover:bg-green-600 transition">
                下一个图案
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('tangramCanvas');
        const ctx = canvas.getContext('2d');
        const resetButton = document.getElementById('resetButton');
        const answerButton = document.getElementById('answerButton');
        const patternSelector = document.getElementById('patternSelector');
        const winModal = document.getElementById('winModal');
        const winPatternName = document.getElementById('winPatternName');
        const nextPatternButton = document.getElementById('nextPatternButton');

        let scale;
        let pieces = [];
        let selectedPiece = null;
        let offsetX, offsetY;
        let lastClickTime = 0;
        let currentPatternIndex = 0;
        let showingAnswer = false;

        const SNAP_DISTANCE = 25;
        
        // --- 几何精确的板块定义 ---
        const pieceDefs = [
            { id: 0, color: '#c0392b', path: [{x:0,y:0}, {x:1,y:0}, {x:0.5,y:0.5}] }, // 小三角1
            { id: 1, color: '#27ae60', path: [{x:0,y:0}, {x:1,y:0}, {x:0.5,y:0.5}] }, // 小三角2
            { id: 2, color: '#2980b9', path: [{x:0,y:0}, {x:2,y:0}, {x:1,y:1}] },    // 大三角1
            { id: 3, color: '#f1c40f', path: [{x:0,y:0}, {x:2,y:0}, {x:1,y:1}] },    // 大三角2
            { id: 4, color: '#8e44ad', path: [{x:0,y:0.5}, {x:1,y:0.5}, {x:0.5,y:0}] }, // 中三角
            { id: 5, color: '#e67e22', path: [{x:0,y:0}, {x:0.5,y:0.5}, {x:1,y:0}, {x:0.5,y:-0.5}] }, // 正方形
            { id: 6, color: '#3498db', path: [{x:0,y:0}, {x:1,y:0}, {x:1.5,y:0.5}, {x:0.5,y:0.5}] }  // 平行四边形
        ];

        // --- 从图例中挑选的全新图案 ---
        const patterns = [
            {
                name: "奔跑的人",
                outline: [{x:0,y:3}, {x:1,y:2}, {x:2,y:3}, {x:2,y:4}, {x:3,y:3}, {x:4,y:4}, {x:4,y:2}, {x:3,y:1}, {x:2,y:2}, {x:2,y:1}, {x:1,y:2}, {x:0,y:1}],
                solution: [
                    { id: 0, x: 2.5, y: 3.5, r: 1 },
                    { id: 1, x: 1.5, y: 1.5, r: 5 },
                    { id: 2, x: 0, y: 2, r: 1 },
                    { id: 3, x: 4, y: 3, r: 5 },
                    { id: 4, x: 2, y: 1, r: 0 },
                    { id: 5, x: 0.5, y: 1.5, r: 0 },
                    { id: 6, x: 3.5, y: 1.5, r: 1 }
                ]
            },
            {
                name: "小鱼",
                outline: [{x:0,y:2}, {x:1,y:1}, {x:2,y:2}, {x:4,y:2}, {x:5,y:3}, {x:4,y:4}, {x:2,y:4}],
                solution: [
                    { id: 0, x: 1.5, y: 1.5, r: 7 },
                    { id: 1, x: 4.5, y: 3.5, r: 5 },
                    { id: 2, x: 0, y: 2, r: 7 },
                    { id: 3, x: 2, y: 4, r: 4 },
                    { id: 4, x: 2, y: 2, r: 4 },
                    { id: 5, x: 2.5, y: 2.5, r: 2 },
                    { id: 6, x: 3.5, y: 2.5, r: 1 }
                ]
            },
            {
                name: "房子",
                outline: [{x:0,y:2}, {x:2,y:0}, {x:4,y:2}, {x:4,y:4}, {x:3,y:5}, {x:1,y:5}, {x:0,y:4}],
                solution: [
                    { id: 0, x: 3.5, y: 4.5, r: 4 },
                    { id: 1, x: 0.5, y: 4.5, r: 5 },
                    { id: 2, x: 2, y: 0, r: 0 },
                    { id: 3, x: 2, y: 4, r: 4 },
                    { id: 4, x: 0, y: 3, r: 3 },
                    { id: 5, x: 2, y: 4, r: 0 },
                    { id: 6, x: 1, y: 3, r: 1 }
                ]
            }
        ];

        function init() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvas.width = size;
            canvas.height = size;
            scale = canvas.width / 8; // Adjust scale for new patterns
            resetPieces();
        }

        function resetPieces() {
            showingAnswer = false;
            answerButton.textContent = "显示答案";
            pieces = pieceDefs.map((def, i) => ({
                ...def,
                x: (i % 4) * 1.8 * scale + scale,
                y: Math.floor(i / 4) * 1.5 * scale + scale * 5.5,
                rotation: 0
            }));
        }

        function drawTargetOutline() {
            const pattern = patterns[currentPatternIndex];
            if (!pattern) return;
            ctx.save();
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 8]);
            const path = pattern.outline;
            const offsetX = canvas.width / 2 - 2.5 * scale; // Adjust offset for centering
            const offsetY = canvas.height / 2 - 2.5 * scale;
            ctx.beginPath();
            ctx.moveTo(path[0].x * scale + offsetX, path[0].y * scale + offsetY);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x * scale + offsetX, path[i].y * scale + offsetY);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }
        
        function drawPiece(piece) {
            ctx.save();
            ctx.translate(piece.x, piece.y);
            ctx.rotate(piece.rotation);
            ctx.beginPath();
            const firstPoint = piece.path[0];
            ctx.moveTo(firstPoint.x * scale, firstPoint.y * scale);
            for (let i = 1; i < piece.path.length; i++) {
                ctx.lineTo(piece.path[i].x * scale, piece.path[i].y * scale);
            }
            ctx.closePath();
            ctx.fillStyle = piece.color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTargetOutline();
            pieces.forEach(drawPiece);
            requestAnimationFrame(gameLoop);
        }

        function getEventPos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function isPointInPiece(pos, piece) {
            ctx.save();
            ctx.translate(piece.x, piece.y);
            ctx.rotate(piece.rotation);
            ctx.beginPath();
            const firstPoint = piece.path[0];
            ctx.moveTo(firstPoint.x * scale, firstPoint.y * scale);
            for (let i = 1; i < piece.path.length; i++) {
                ctx.lineTo(piece.path[i].x * scale, piece.path[i].y * scale);
            }
            ctx.closePath();
            const result = ctx.isPointInPath(pos.x, pos.y);
            ctx.restore();
            return result;
        }

        function handleStart(evt) {
            if (showingAnswer) return;
            evt.preventDefault();
            const pos = getEventPos(evt);
            
            for (let i = pieces.length - 1; i >= 0; i--) {
                if (isPointInPiece(pos, pieces[i])) {
                    selectedPiece = pieces[i];
                    pieces.splice(i, 1);
                    pieces.push(selectedPiece);
                    offsetX = pos.x - selectedPiece.x;
                    offsetY = pos.y - selectedPiece.y;
                    const currentTime = new Date().getTime();
                    if (currentTime - lastClickTime < 300) {
                        selectedPiece.rotation += Math.PI / 4;
                    }
                    lastClickTime = currentTime;
                    canvas.addEventListener('mousemove', handleMove);
                    canvas.addEventListener('touchmove', handleMove, { passive: false });
                    canvas.addEventListener('mouseup', handleEnd);
                    canvas.addEventListener('touchend', handleEnd);
                    canvas.addEventListener('mouseleave', handleEnd);
                    return;
                }
            }
        }

        function handleMove(evt) {
            if (!selectedPiece) return;
            evt.preventDefault();
            const pos = getEventPos(evt);
            selectedPiece.x = pos.x - offsetX;
            selectedPiece.y = pos.y - offsetY;
        }

        function handleEnd() {
            if (selectedPiece) {
                snapPiece(selectedPiece);
                checkWin();
            }
            selectedPiece = null;
            canvas.removeEventListener('mousemove', handleMove);
            canvas.removeEventListener('touchmove', handleMove);
            canvas.removeEventListener('mouseup', handleEnd);
            canvas.removeEventListener('touchend', handleEnd);
            canvas.removeEventListener('mouseleave', handleEnd);
        }

        function getTargetPosition(solutionEntry) {
            const offsetX = canvas.width / 2 - 2.5 * scale;
            const offsetY = canvas.height / 2 - 2.5 * scale;
            return {
                x: solutionEntry.x * scale + offsetX,
                y: solutionEntry.y * scale + offsetY,
                rotation: solutionEntry.r * Math.PI / 4
            };
        }

        function snapPiece(piece) {
            const solution = patterns[currentPatternIndex].solution;
            const sol = solution.find(s => s.id === piece.id);
            if (sol) {
                const target = getTargetPosition(sol);
                const dist = Math.hypot(piece.x - target.x, piece.y - target.y);
                if (dist < SNAP_DISTANCE) {
                    const rotDiff = Math.abs((piece.rotation % (2*Math.PI)) - (target.rotation % (2*Math.PI)));
                    if (Math.min(rotDiff, 2*Math.PI - rotDiff) < Math.PI / 8) {
                         piece.x = target.x;
                         piece.y = target.y;
                         piece.rotation = target.rotation;
                    }
                }
            }
        }

        function checkWin() {
            const solution = patterns[currentPatternIndex].solution;
            const isWin = pieces.every(piece => {
                const sol = solution.find(s => s.id === piece.id);
                if (!sol) return false;
                const target = getTargetPosition(sol);
                const posCheck = Math.hypot(piece.x - target.x, piece.y - target.y) < 5;
                const rotDiff = Math.abs((piece.rotation % (2*Math.PI)) - (target.rotation % (2*Math.PI)));
                const rotCheck = Math.min(rotDiff, 2*Math.PI - rotDiff) < 0.1;
                return posCheck && rotCheck;
            });
            if (isWin) {
                showWinModal();
            }
        }

        function showWinModal() {
            winPatternName.textContent = patterns[currentPatternIndex].name;
            winModal.classList.remove('opacity-0', 'pointer-events-none');
            winModal.querySelector('div').classList.remove('scale-95');
        }
        
        function hideWinModal() {
            winModal.classList.add('opacity-0', 'pointer-events-none');
            winModal.querySelector('div').classList.add('scale-95');
        }

        function setupPatternSelector() {
            patternSelector.innerHTML = '';
            patterns.forEach((p, index) => {
                const button = document.createElement('button');
                button.textContent = p.name;
                button.className = 'pattern-btn px-4 py-2 rounded-lg font-semibold transition bg-slate-200 text-slate-700 hover:bg-slate-300';
                if (index === currentPatternIndex) {
                    button.classList.add('active');
                }
                button.onclick = () => {
                    currentPatternIndex = index;
                    setupPatternSelector();
                    resetPieces();
                };
                patternSelector.appendChild(button);
            });
        }
        
        function solvePuzzle() {
            const solution = patterns[currentPatternIndex].solution;
            pieces.forEach(piece => {
                const sol = solution.find(s => s.id === piece.id);
                if (sol) {
                    const target = getTargetPosition(sol);
                    piece.x = target.x;
                    piece.y = target.y;
                    piece.rotation = target.rotation;
                }
            });
        }

        function toggleAnswer() {
            showingAnswer = !showingAnswer;
            if (showingAnswer) {
                solvePuzzle();
                answerButton.textContent = "隐藏答案";
            } else {
                resetPieces();
                answerButton.textContent = "显示答案";
            }
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        resetButton.addEventListener('click', resetPieces);
        answerButton.addEventListener('click', toggleAnswer);
        nextPatternButton.addEventListener('click', () => {
             currentPatternIndex = (currentPatternIndex + 1) % patterns.length;
             setupPatternSelector();
             resetPieces();
             hideWinModal();
        });
        window.addEventListener('resize', init);

        setupPatternSelector();
        init();
        gameLoop();
    </script>
</body>
</html>

